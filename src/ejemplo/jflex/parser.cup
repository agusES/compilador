package ejemplo.jflex;

import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.List;
import java.io.FileReader;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.lang.NumberFormatException;
import java.lang.IllegalArgumentException;
import java.lang.TypeNotPresentException;
import java.lang.Throwable;
import ejemplo.nodos.*;

class MiParser;

parser code
{:
    public void syntax_error(Symbol s){
        System.out.println("Error en la linea "+ (s.left+1)+ " Columna "+ s.right+ ". Valor simbolo '"
        +s.value+"' . Simbolo n° "+s.sym+ " no reconocido." );
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
        System.out.println("Error en la linea "+ (s.left+1)+ " Columna "+ s.right+ ". Valor simbolo '"
        +s.value+"' . Simbolo n° "+s.sym+ " no reconocido." );
    }

:};


terminal MAIN, CONST, LLAVEABRE, LLAVECIERRA, ID, VARS, INT, FLOAT, BOOLEAN, IF, THEN, ELSE, WHILE, DO , UNTIL, REPEAT, MAS, MENOS, POR, DIVIDIDO, SHOW;
terminal MAYOR, MENOR, EQUAL, DIFF, MAYOREQUAL, MENOREQUAL, PUNTO_COMA, TRUE, FALSE, AND, OR, BETWEEN, STRING, PARENABRE, PARENCIERRA, IGUAL, DOSPUNTOS, ENTERO, FLOTANTE;
nonterminal programa, const, constantes, constante, vars, sentencias, variables, variable, termino, factor, comparador, termbool;
nonterminal expbool, between, bloque, ids, sentencia, asig, asigs, if, while, until, condicion, exp, tipo, show;

start with programa;

programa ::= MAIN const vars sentencias
            {:  
                System.out.println("Soy un Programa");
            :};

bloque ::= LLAVEABRE sentencias LLAVECIERRA {: System.out.println("Soy un bloque"); RESULT="bloque";:};


sentencias ::= sentencias sentencia PUNTO_COMA {: System.out.println("Soy muchas sentencias"); :} 
| sentencia PUNTO_COMA {:System.out.println("Soy una sentencia");:};

const ::= CONST LLAVEABRE constantes LLAVECIERRA{:  
                System.out.println("SECTOR CONSTANTES");
            :}|{:
                System.out.println("NO HAY CONSTANTES");
                RESULT=(Symbol) null;
:};


constantes ::= constante {:
                System.out.println("UNA CONSTANTE");

            :}| constantes constante {:
                System.out.println("VARIAS CONSTANTES");
:};

constante ::= ID DOSPUNTOS tipo:t IGUAL exp:e PUNTO_COMA{:
                System.out.println("CONSTANTE");
                switch(t.toString()){
                    case "int":
                        if (!(Integer.class.isInstance(e))) {
                            System.out.println("ERROR EN TIPO ENTERO");
                            throw new IllegalArgumentException ("El argumento debe ser un número entero");
                        }
                        break;
                    case "float":
                        if (!(Float.class.isInstance(e))) {
                            System.out.println("ERROR EN TIPO FLOTANTE");
                            throw new IllegalArgumentException ("El argumento debe ser un número flotante");
                        }
                        break;
                    case "boolean":
                        if (e != ".T." && e != ".F.") {
                            System.out.println("ERROR EN TIPO BOOLEANO");
                            throw new IllegalArgumentException ("El argumento debe ser una expresion booleana");
                        }
                        break;
                    default:
                        System.out.println("NO ES UN TIPO");
                        break; 
                }
:};

vars ::= VARS LLAVEABRE variables LLAVECIERRA
            {:  
                System.out.println("SECTOR VARIABLES");
            :}|{:
                System.out.println("NO HAY VARIABLES");
:};

tipo ::= INT:i {:
            System.out.println("Soy un tipo ENTERO");
            RESULT = i;
        :} 
        | FLOAT:f {:
            System.out.println("Soy un tipo FLOAT");
            RESULT = f;
        :}
        | BOOLEAN:b {:
            System.out.println("Soy un tipo BOOLEAN");
            RESULT = b;
        :}
        ;

variables ::= variable {:
                System.out.println("UNA VARIABLE");

:} |
              variables variable {:
                System.out.println("VARIAS VARIABLES");

:};

variable ::= ids DOSPUNTOS tipo PUNTO_COMA{:
                System.out.println("VARIABLE");

:};

ids ::= ID {:
        System.out.println("UN ID");
:} | ids ID {:
        System.out.println("VARIOS IDS");

:};

sentencia ::= asig {: System.out.println("Soy una asignacion simple en una sentencia");:} 
            | asigs {: System.out.println("Soy una asignacion compleja en una sentencia");:} 
            | if {: System.out.println("Sou un if en una sentencia");:} 
            | while {: System.out.println("Soy un while en una sentencia");:} 
            | until {: System.out.println("Soy un until en una sentencia");:}
            | show {: System.out.println("Soy un show en una sentencia");:};

asig ::= ID IGUAL exp {:
    System.out.println("soy una asignacion comun");
:}| ID IGUAL expbool{:System.out.println("soy una asignacion booleana"); :};

asigs ::= ID IGUAL asig {:
    System.out.println("Soy una asignacion simple");
:} | ID IGUAL asigs {:
    System.out.println("Soy una asignacion compleja");
:};

if ::= IF condicion:c THEN bloque:b {: 
                System.out.println("if " + c + " then " + b);
       :} |
       IF condicion THEN bloque ELSE bloque {:
                System.out.println("Soy un if con else");
       :};

while ::= WHILE condicion DO bloque {:System.out.println("Soy un while");:};

until ::= UNTIL condicion REPEAT bloque {:System.out.println("Soy un until");:};

show ::= SHOW PARENABRE STRING:s PARENCIERRA {:System.out.println("Soy un show con string: " + s.toString());:};

between ::= exp:e1 BETWEEN exp:e2 AND exp:e3 {:System.out.println( e1 + " between " + e2 + " AND " + e3);:};

condicion ::= PARENABRE exp:e comparador:c exp:e2 PARENCIERRA {: RESULT= "(" + e + c+ e2+")";:}
 | PARENABRE expbool:e3 PARENCIERRA {: RESULT= "(" + e3 +")";:};


comparador ::= MAYOR:ma {: RESULT= ma;:} 
| MENOR:me {: System.out.println("Soy un menor");RESULT= me; :}
| EQUAL:eq {: System.out.println("Soy un igual");RESULT= eq; :}
| DIFF:dif {: System.out.println("Soy un distinto");RESULT= dif; :}
| MAYOREQUAL:ge {: System.out.println("Soy un mayor o igual");RESULT= ge; :}
| MENOREQUAL:me {: System.out.println("Soy un menor o igual");RESULT= me; :};


exp ::= exp:e MAS termino:t {:
                System.out.println("expresion::=expresion+factor;");
                RESULT = new Suma(e,t);
            :}
            |
            exp MENOS termino {:
                System.out.println("expresion::=expresion-factor;");
                RESULT = new Resta(e,t);
            :}
             |
             termino:t {:
                System.out.println("expresion::=termino;");
                RESULT= t;
            :};

termbool ::= TRUE:t {:
                System.out.println("Soy un TRUE");
                RESULT= t;
            :}
            | FALSE:f{: System.out.println("Soy un FALSE");
                RESULT= f;
            :}
            |
            between:b {:
                System.out.println("expresion::=between;");
                RESULT= b;
            :}
            | condicion: c {: System.out.println("Soy una condicion en termino bool");
                RESULT= c; :};

expbool ::=  expbool:e1 AND:a termbool:e2 {: System.out.println("Soy un AND");RESULT= e1 +" and "+ e2; :}
            | expbool:e3 OR:o termbool:e4 {: System.out.println("Soy un OR"); RESULT= e3 +" or "+ e4;:}
            | termbool:t {: 
                 RESULT= t;
                :};

termino ::= termino:t POR factor:f {:
                System.out.println("termino::=factor*termino;");
                RESULT = new Multiplicacion(t,f);
            :}
            |
            termino:t DIVIDIDO factor:f {:
                System.out.println("termino::=factor/termino;");
                RESULT = new Division(t,f);
            :}
            |
            factor:f {:
                 RESULT= f;
            :}; 
factor ::= ENTERO:e {:
            Integer entero = null;
            try{
                entero = Integer.valueOf(e.toString());
            }catch(NumberFormatException  ex){
                System.out.println("El valor no corresponde a un número entero");
            }    
            RESULT= entero;
             :}
             | FLOTANTE:f {:
             Float flotante = null;
             try{
                flotante = Float.valueOf(f.toString());
            }catch(NumberFormatException  ex){
                System.out.println("El valor no corresponde a un número flotante");
            }    
            RESULT= flotante;
             :}

             |
             ID:identificador {:
                RESULT = identificador;
             :}
            |
            PARENABRE exp:e PARENCIERRA {:
                 RESULT = e;
            :};